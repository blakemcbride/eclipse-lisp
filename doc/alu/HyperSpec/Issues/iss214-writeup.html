<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!-- Common Lisp HyperSpec (TM), version 3.0 generated by kmp on Thu, 2-May-1996 10:21am EDT -->
<HTML>
<HEAD>
<TITLE>CLHS: Issue LISP-SYMBOL-REDEFINITION Writeup</TITLE>
<META HTTP-EQUIV="Author" CONTENT="Kent M. Pitman">
<META HTTP-EQUIV="Organization" CONTENT="The Harlequin Group Limited">
<LINK REL=TOP HREF="../FrontMatter/index.html">
<LINK REL=COPYRIGHT HREF="../FrontMatter/About-HyperSpec.html#Legal">
<LINK REL=DISCLAIMER HREF="../FrontMatter/About-HyperSpec.html#Disclaimer">
<LINK REL=PREV HREF="../Issues/iss213-writeup.html">
<LINK REL=UP HREF="../Issues/iss214.html">
<LINK REL=NEXT HREF="../Issues/iss215-writeup.html">
</HEAD>
<BODY BGCOLOR="#c0c0c0">
<H1><A REV=MADE HREF="http://www.harlequin.com/"><IMG ALT="[HARLEQUIN]" SRC="../Graphics/Harlequin-Small.gif" ALIGN=Bottom></A><A REL=TOP HREF="../FrontMatter/index.html"><IMG ALT="[Common Lisp HyperSpec (TM)]" SRC="../Graphics/HyperSpec-Small.gif" ALIGN=Bottom></A> <A REL=PREV HREF="../Issues/iss213-writeup.html"><IMG ALT="[Previous]" SRC="../Graphics/Prev.gif" ALIGN=Bottom></A><A REL=UP HREF="../Issues/iss214.html"><IMG ALT="[Up]" SRC="../Graphics/Up.gif" ALIGN=Bottom></A><A REL=NEXT HREF="../Issues/iss215-writeup.html"><IMG ALT="[Next]" SRC="../Graphics/Next.gif" ALIGN=Bottom></A></H1>

<HR>



<H2>Issue LISP-SYMBOL-REDEFINITION Writeup</H2>

<PRE><B>Status:</B>	       Version 8 passed (superseding version 6), 6/8/90<P>
<P>
<B>Forum:</B>         Cleanup<P>
<B>Issue:</B>         <A HREF="iss214.html">LISP-SYMBOL-REDEFINITION</A><P>
 <P>
<B>References:</B>    Cleanup issue <A HREF="iss252.html">PACKAGE-CLUTTER</A><P>
               CLtL pp 67-69 Defining named functions<P>
	       CLtL pp 101-106 Generalized variables<P>
	       Cleanup issue <A HREF="iss174.html">FUNCTION-NAME</A><P>
	       Condition System, version 18<P>
	       CLOS specification, 88-002R<P>
 <P>
<B>Category:</B>      CLARIFICATION<P>
 <P>
<B>Edit history:</B>  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)<P>
               Masinter, Version 2, 7-Oct-88<P>
               Masinter, Version 3,  7-Oct-88, fix typos<P>
               van Roggen, Version 4, 13-Oct-88, undefined, not unspecified<P>
               Masinter, Version 5, 22-Nov-88, add more cases<P>
	       Masinter, Version 6,  9-Apr-89, make Mar 89 X3j13 amendments<P>
	       Barrett, Version 7, 3-Jan-90, add more cases<P>
	       Barrett, Version 8, 9-Jan-90, make Jun 90 X3J13 ammendments<P>
 <P>
<B>Problem description:<P>
</B> <P>
Is it legal to redefine Common Lisp functions? There is no explicit<P>
prohibition, and many implementations do allow redefinition of<P>
functions in the Lisp package.<P>
 <P>
CLtL only says that special forms can not be redefined. But this doesn't <P>
solve the general problem of redefining system functions.<P>
 <P>
Proposal <A HREF="iss214.html">LISP-SYMBOL-REDEFINITION:MAR89-X3J13</A><P>
<P>
Except where explicitly allowed, the consequences are undefined if any of the<P>
following actions are performed on symbols exported from the COMMON-LISP<P>
package:<P>
<P>
1. Binding or altering its value (lexically or dynamically)<P>
2. Defining, undefining, or binding it as a function<P>
3. Defining, undefining, or binding it as a macro or <A REL=DEFINITION HREF="../Body/stagenfun_doc_umentationcp.html#compiler-macro"><B>compiler-macro</B></A><P>
4. Defining it as a type specifier (<A REL=DEFINITION HREF="../Body/mac_defstruct.html#defstruct"><B>defstruct</B></A>, <A REL=DEFINITION HREF="../Body/mac_defclass.html#defclass"><B>defclass</B></A>, <A REL=DEFINITION HREF="../Body/mac_define-condition.html#define-condition"><B>define-condition</B></A>,<P>
   <A REL=DEFINITION HREF="../Body/mac_deftype.html#deftype"><B>deftype</B></A>)<P>
5. Defining it as a <A REL=DEFINITION HREF="../Body/stagenfun_doc_umentationcp.html#structure"><B>structure</B></A> (<A REL=DEFINITION HREF="../Body/mac_defstruct.html#defstruct"><B>defstruct</B></A>)<P>
6. Defining it as a declaration (declaration, define-declaration)<P>
7. Using it as a symbol macro<P>
8. Altering its print name (this may already be prohibited)<P>
9. Altering its package<P>
10. Tracing it<P>
11. Declaring or proclaiming it special<P>
12. Declaring or proclaiming its type or <A REL=DEFINITION HREF="../Body/dec_ftype.html#ftype"><B>ftype</B></A><P>
13. Uninterning or unexporting it from the package COMMON-LISP<P>
14. Defining a <A REL=DEFINITION HREF="../Body/any_setf.html#setf"><B>setf</B></A> <A REL=DEFINITION HREF="../Body/syscla_method.html#method"><B>method</B></A> for it (<A REL=DEFINITION HREF="../Body/mac_defsetf.html#defsetf"><B>defsetf</B></A>, define-setf-method, defining,<P>
    undefining, or binding the function named (<A REL=DEFINITION HREF="../Body/any_setf.html#setf"><B>SETF</B></A> symbol))<P>
15. Defining it as a <A REL=DEFINITION HREF="../Body/syscla_method.html#method"><B>method</B></A> combination type<P>
16. Using it as the <A REL=DEFINITION HREF="../Body/stagenfun_class-name.html#class-name"><B>class-name</B></A> argument to <A REL=DEFINITION HREF="../Body/any_setf.html#setf"><B>SETF</B></A> of <A REL=DEFINITION HREF="../Body/acc_find-class.html#find-class"><B>FIND-CLASS</B></A><P>
<P>
If such a symbol is not globally defined as a variable or a constant, it is<P>
allowed to lexically bind it as a variable or as a symbol-macro and declare the<P>
type of that binding.<P>
<P>
If such a symbol is not defined as a function, macro, or special form,<P>
it is allowed to (lexically) bind it as a function and to declare the<P>
<A REL=DEFINITION HREF="../Body/dec_ftype.html#ftype"><B>ftype</B></A> of that binding and to <A REL=DEFINITION HREF="../Body/mac_tracecm_untrace.html#trace"><B>trace</B></A> that binding.<P>
<P>
If such a symbol is not defined as a function, macro, or special form,<P>
it is allowed to (lexically) bind it as a macro.<P>
<P>
If such a symbol does not have a <A REL=DEFINITION HREF="../Body/any_setf.html#setf"><B>setf</B></A> <A REL=DEFINITION HREF="../Body/syscla_method.html#method"><B>method</B></A> defined for it, it is allowed to<P>
(lexically) bind the function named (<A REL=DEFINITION HREF="../Body/any_setf.html#setf"><B>SETF</B></A> symbol).<P>
<P>
<B>Examples:<P>
</B> <P>
The behavior of the construct:<P>
 <P>
(<A REL=DEFINITION HREF="../Body/speope_fletcm_scm_macrolet.html#flet"><B>FLET</B></A> ((<A REL=DEFINITION HREF="../Body/fun_open.html#open"><B>OPEN</B></A> (filename <A REL=DEFINITION HREF="../Body/sec_3-4-1.html#AMkey"><B>&amp;key</B></A> direction) (<A REL=DEFINITION HREF="../Body/fun_format.html#format"><B>format</B></A> t &quot;Open called....&quot;) <P>
			(<A REL=DEFINITION HREF="../Body/fun_open.html#open"><B>OPEN</B></A> filename :direction direction)))<P>
    (<A REL=DEFINITION HREF="../Body/mac_with-open-file.html#with-open-file"><B>with-open-file</B></A> (x &quot;frob&quot; :direction ':output) <P>
		(<A REL=DEFINITION HREF="../Body/fun_format.html#format"><B>format</B></A> t &quot;was Open called?&quot;)))<P>
 <P>
is undefined; for example, the macro expansion of <A REL=DEFINITION HREF="../Body/mac_with-open-file.html#with-open-file"><B>with-open-file</B></A> might refer<P>
to the <A REL=DEFINITION HREF="../Body/fun_open.html#open"><B>OPEN</B></A> function and might not.<P>
 <P>
(<A REL=DEFINITION HREF="../Body/mac_defun.html#defun"><B>DEFUN</B></A> <A REL=DEFINITION HREF="../Body/acc_carcm_cdr_darcm_cddddr.html#car"><B>CAR</B></A> (X) (<A REL=DEFINITION HREF="../Body/acc_carcm_cdr_darcm_cddddr.html#cdr"><B>CDR</B></A> X))<P>
 <P>
might signal an error.<P>
 <P>
<B>Rationale:<P>
</B> <P>
This proposal is the only simple resolution of the problem description that<P>
we can imagine that is consistent with current implementation techniques.<P>
 <P>
Allowing arbitrary redefinition of symbols in the system would place<P>
severe restrictions on implementations not to actually use those symbols in<P>
macro expansions of other symbols, in function calls, etc. While some<P>
looser restrictions might do for any particular Common Lisp implementation,<P>
there seems to be no good way to distinguish between those symbols that are<P>
redefinable and those that are not.<P>
 <P>
In general, programs can redefine functions safely by creating new symbols in<P>
their own package, possibly shadowing the name.<P>
 <P>
<B>Current practice:<P>
</B> <P>
Many Lisp environments have some mechanism for warning about redefinition of<P>
Lisp symbols and preventing accidental redefinition while allowing it where<P>
necessary (e.g., to patch the Lisp system itself, fix a bug, add an<P>
optimization.)<P>
 <P>
Fewer check for lexical redefinition, since such redefinition is not as<P>
dangerous. Certainly, there are some symbols that are never used in macro<P>
expansions of the <A REL=DEFINITION HREF="../Body/sec_7-6-6-2.html#standard"><B>standard</B></A> Common Lisp macros. However, implementations do<P>
differ on the behavior of macro expansions.<P>
 <P>
<B>Cost to Implementors:<P>
</B> <P>
This proposal clarifies the status quo -- that the consequences are undefined.<P>
It allows and encourages implementors to check for such redefinition, but does<P>
not <A REL=DEFINITION HREF="../Body/fun_providecm_require.html#require"><B>require</B></A> it.<P>
 <P>
<B>Cost to Users:<P>
</B> <P>
This proposal clarifies that implementations are free to check for a condition<P>
that they might not have before, and may clarify that some current user code is<P>
non-portable.<P>
 <P>
<B>Benefits:<P>
</B> <P>
This issue frequently arises. Adopting this proposal would clarify a frequent<P>
source of question about Common Lisp. <P>
 <P>
<B>Cost of non-adoption:<P>
</B> <P>
Continued questions.<P>
 <P>
<B>Esthetics:<P>
</B> <P>
Disallowing all redefinition is the simplest way of disallowing the ones that<P>
really are trouble. <P>
 <P>
<B>Discussion:<P>
</B> <P>
At the March 89 X3j13 meeting, a proposed additional constraint <P>
(&quot;Altering its property list&quot;) was removed. Presumably this means<P>
that conformal programs are allowed to alter the property list of<P>
 symbols in the COMMON-LISP package.<P>
</PRE>

<HR>

<A REL=NAVIGATOR HREF="../FrontMatter/Starting-Points.html"><IMG ALT="[Starting Points]" SRC="../Graphics/Starting-Points.gif" ALIGN=Bottom></A><A REL=TOC HREF="../FrontMatter/Chapter-Index.html"><IMG ALT="[Contents]" SRC="../Graphics/Contents.gif" ALIGN=Bottom></A><A REL=INDEX HREF="../FrontMatter/Master-Index.html"><IMG ALT="[Index]" SRC="../Graphics/Index.gif" ALIGN=Bottom></A><A REL=INDEX HREF="../FrontMatter/Symbol-Index.html"><IMG ALT="[Symbols]" SRC="../Graphics/Symbols.gif" ALIGN=Bottom></A><A REL=GLOSSARY HREF="../Body/sec_26-1.html"><IMG ALT="[Glossary]" SRC="../Graphics/Glossary.gif" ALIGN=Bottom></A><A HREF="../Issues/Issues-Categorized.html"><IMG ALT="[Issues]" SRC="../Graphics/Issues.gif" ALIGN=Bottom></A><BR>

<A REL=COPYRIGHT HREF="../FrontMatter/About-HyperSpec.html#Legal"><I>Copyright 1996, The Harlequin Group Limited.  All Rights Reserved.</I></A><P>
</BODY>
</HTML>
