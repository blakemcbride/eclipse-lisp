/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Tuesday the fifth of May, 1998, 3:51:36 pm CDT. */
#include <eclipse.h>

clObject clAddIntegerInteger __P((clObject, clObject)),
  clApply(clProto), clCaar(clProto), clCar(clProto), clCdar(clProto),
  clCdr(clProto), clCharpSimpleBaseString __P((clCharp)),
  clCons(clProto), clConsp(clProto), clCopyList(clProto),
  clEndp(clProto), clEq(clProto),
  clEqDoubleFloatDoubleFloat __P((clObject, clObject)),
  clEqIntegerInteger __P((clObject, clObject)),
  clEqSingleFloatSingleFloat __P((clObject, clObject)), clEql(clProto),
  clEqlHash(clProto), clError(clProto), clExtraArgs(clProto),
  clFdefinition1(clProto), clFixnump(clProto), clFloor(clProto),
  clFuncall(clProto), clFunctionNameKey(clProto),
  cl_SETF_GlobalDeclaration(clProto), clKeyItem(clProto),
  clLast(clProto), clLengthList(clProto), clList(clProto),
  clListEq(clProto), clMakeKeyword(clProto), clMap1(clProto),
  clMissingArgs(clProto), clNconc(clProto), clNot(clProto),
  clNull(clProto), clRplaca(clProto), clRplacd(clProto),
  clSetFdefinition1(clProto), clSetfFunctionNameP(clProto),
  clStandardInstanceAccess(clProto), clSymbolp(clProto);

extern clObject clBASE_STRING, clBIT_VECTOR, clCONS, clDOUBLE_FLOAT,
  clINTEGER, clRATIO, clSEQUENCE, clSINGLE_FLOAT, clSPECIAL, clSYMBOL,
  clstarCIRCULARITY_HASH_TABLEstar, clstarCURRENT_LENGTHstar,
  clstarCURRENT_LEVELstar, clstarDEBUG_IOstar,
  clstarDEFAULT_RIGHT_MARGINstar, clstarERROR_OUTPUTstar,
  clstarFEATURESstar, clstarNULL_OUTPUTstar, clstarPARENTSstar,
  clstarPRINT_ARRAYstar, clstarPRINT_BASEstar, clstarPRINT_CASEstar,
  clstarPRINT_CIRCLEstar, clstarPRINT_ESCAPEstar,
  clstarPRINT_GENSYMstar, clstarPRINT_LENGTHstar,
  clstarPRINT_LEVELstar, clstarPRINT_LINESstar,
  clstarPRINT_MISER_WIDTHstar, clstarPRINT_PRETTYstar,
  clstarPRINT_RADIXstar, clstarPRINT_READABLYstar,
  clstarPRINT_RIGHT_MARGINstar, clstarQUERY_IOstar,
  clstarSTANDARD_INPUTstar, clstarSTANDARD_OUTPUTstar,
  clstarTERMINAL_IOstar, clstarTRACE_OUTPUTstar, clABS, clATOM,
  clBOUNDP, clCHARACTER_CLASSOBJ, clCHARACTERP, clCLASS_NAME_OF,
  clCLASS_PRECEDENCE_LIST_OF, clCOMPLEMENT, clCOMPLEX,
  clCOMPLEX_BASE_STRING, clCOMPLEX_BIT_VECTOR, clCOMPLEX_CLASSOBJ,
  clCOMPLEX_EXTENDED_STRING, clCOMPLEX_VECTOR, clCOMPLEXP,
  clCONS_CLASSOBJ, clCONSP, clDOUBLE_FLOAT_CLASSOBJ, clDOUBLE_FLOAT_P,
  clENDP, clEQ_NUMBER, clEQL, clEQL_HASH, clEXTENDED_STRING, clFBOUNDP,
  clFDEFINITION, clFDEFINITION1, clFIND_LIST_EQ, clFMAKUNBOUND,
  clGENERAL_VECTOR, clGLOBAL_VARIABLE, clIDENTITY, clINTEGER_CLASSOBJ,
  clINTEGERP, clKEY_ITEM, clLENGTH, clLENGTH_LIST, clLIST, clLIST_EQ,
  clLISTP, clLT, clMAP1, clMAPC, clMAPCAN, clMAPCAR, clMULT, clNONE,
  clNOT, clNREVERSE, clNULL, clRATIO_CLASSOBJ, clRATIOP,
  clSATISFIES_THE_TEST, clSET_FDEFINITION1, clSETF,
  clSIMPLE_BASE_STRING, clSIMPLE_BIT_VECTOR,
  clSIMPLE_BIT_VECTOR_CLASSOBJ, clSIMPLE_BIT_VECTOR_P,
  clSIMPLE_EXTENDED_STRING, clSIMPLE_VECTOR, clSIMPLE_VECTOR_CLASSOBJ,
  clSIMPLE_VECTOR_P, clSINGLE_FLOAT_CLASSOBJ, clSINGLE_FLOAT_P,
  clSYMBOL_CLASSOBJ, clSYMBOLP, clTYPE_ERROR, clUNDEFINED_FUNCTION;

static clObject CONS_0, CONS_1, CONS_10, CONS_11, CONS_12, CONS_13,
  CONS_14, CONS_15, CONS_2, CONS_3, CONS_4, CONS_5, CONS_6, CONS_7,
  CONS_8, CONS_9, I_0, I_1, I_10, I_1000, I_2, I_3, I_4, I_40, I_5,
  I_6, I_72, keyDATUM, keyEXPECTED_TYPE, keyLIST, keyNAME, keyNCONC,
  keyUPCASE, STR_DATUM__1, STR_EXPECTED_TYPE__0, STR_LIST__4,
  STR_NAME__2, STR_NCONC__3, STR_UPCASE__5;

clObject clClassNameOf clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clStandardInstanceAccess(L_0, I_2, clEOA)); } }

clObject clClassPrecedenceListOf clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clStandardInstanceAccess(L_0, I_6, clEOA)); } }

clObject clFindListEq clVdecl(_ap)
{ clObject item, list;
  { clBeginParse(_ap);
    clSetq(item,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clLabel(l_LOOP0);
  { clObject L_test;
    { clObject L_0;
      clSetq(L_0, list);
      clSetq(L_test, clConsp(L_0, clEOA)); }
    if (clTrue(L_test))
      { { clObject L_test__R1;
          { clObject L_1, L_0;
            clSetq(L_0, item);
            { clObject L_0__R1;
              clSetq(L_0__R1, list);
              clSetq(L_1, clCar(L_0__R1, clEOA)); }
            clSetq(L_test__R1, clEq(L_0, L_1, clEOA)); }
          if (clTrue(L_test__R1)) return(clValues1(item)); }
        { clObject L_0;
          clSetq(L_0, list);
          clSetq(list, clCdr(L_0, clEOA)); } }
    else return(clValues1(clNIL)); }
  goto l_LOOP0; }

clObject clNull clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, object);
    return(clEq(L_0, clNIL, clEOA)); } }

clObject clAtom clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, object);
      clSetq(L_0, clConsp(L_0__R1, clEOA)); }
    return(clNot(L_0, clEOA)); } }

clObject clConsp clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clCONS_CLASSOBJ, clEOA)); } }

clObject clCharacterp clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clCHARACTER_CLASSOBJ, clEOA)); } }

clObject clIntegerp clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clINTEGER_CLASSOBJ, clEOA)); } }

clObject clComplexp clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clCOMPLEX_CLASSOBJ, clEOA)); } }

clObject clSimpleVectorP clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clSIMPLE_VECTOR_CLASSOBJ, clEOA)); } }

clObject clSimpleBitVectorP clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clSIMPLE_BIT_VECTOR_CLASSOBJ, clEOA)); } }

clObject clRatiop clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clRATIO_CLASSOBJ, clEOA)); } }

clObject clSingleFloatP clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clSINGLE_FLOAT_CLASSOBJ, clEOA)); } }

clObject clDoubleFloatP clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, x);
      clSetq(L_0, clObjectClass(L_0__R1)); }
    return(clEq(L_0, clDOUBLE_FLOAT_CLASSOBJ, clEOA)); } }

clObject clSymbolp clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g467;
    { clObject L_0;
      clSetq(L_0, x);
      clSetq(L_g467, clEq(L_0, clNIL, clEOA)); }
    if (clTrue(L_g467))
      return(clValues1(L_g467));
    else
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, x);
          clSetq(L_0, clObjectClass(L_0__R1)); }
        return(clEq(L_0, clSYMBOL_CLASSOBJ, clEOA)); } } }

clObject clListp clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g472;
    { clObject L_0;
      clSetq(L_0, x);
      clSetq(L_g472, clEq(L_0, clNIL, clEOA)); }
    if (clTrue(L_g472))
      return(clValues1(L_g472));
    else
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, x);
          clSetq(L_0, clObjectClass(L_0__R1)); }
        return(clEq(L_0, clCONS_CLASSOBJ, clEOA)); } } }

clObject clEql clVdecl(_ap)
{ clObject x, y;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(y, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_1, L_0;
      clSetq(L_0, x);
      clSetq(L_1, y);
      clSetq(L_test, clEq(L_0, L_1, clEOA)); }
    if (clTrue(L_test))
      return(clValues1(clT));
    else
      { clObject x_class, y_class;
        { clObject L_0;
          clSetq(L_0, x);
          clSetq(x_class, clObjectClass(L_0)); }
        { clObject L_0;
          clSetq(L_0, y);
          clSetq(y_class, clObjectClass(L_0)); }
        if (_clEq(x_class, y_class))
          if (_clEq(clINTEGER_CLASSOBJ, x_class))
            { clObject L_1, L_0;
              clSetq(L_0, x);
              clSetq(L_1, y);
              return(clValues1(clEqIntegerInteger(L_0, L_1))); }
          else if (_clEq(clDOUBLE_FLOAT_CLASSOBJ, x_class))
            { clObject L_1, L_0;
              clSetq(L_0, x);
              clSetq(L_1, y);
              return(clValues1(clEqDoubleFloatDoubleFloat(L_0,
                                                          L_1))); }
          else if (_clEq(clSINGLE_FLOAT_CLASSOBJ, x_class))
            { clObject L_1, L_0;
              clSetq(L_0, x);
              clSetq(L_1, y);
              return(clValues1(clEqSingleFloatSingleFloat(L_0,
                                                          L_1))); }
          else if (_clEq(clRATIO_CLASSOBJ, x_class))
            { clObject L_1, L_0;
              clSetq(L_0, x);
              clSetq(L_1, y);
              return(clFuncallFunction(clSymbolFunctionValue(clEQ_NUMBER),
                                       L_0,
                                       L_1,
                                       clEOA)); }
          else if (_clEq(clCOMPLEX_CLASSOBJ, x_class))
            { clObject L_test__R7;
              { clObject L_1, L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, x);
                  clSetq(L_0, clComplexRealpart(L_0__R1)); }
                { clObject L_0__R1;
                  clSetq(L_0__R1, y);
                  clSetq(L_1, clComplexRealpart(L_0__R1)); }
                clSetq(L_test__R7, clEql(L_0, L_1, clEOA)); }
              if (clTrue(L_test__R7))
                { clObject L_1, L_0;
                  { clObject L_0__R1;
                    clSetq(L_0__R1, x);
                    clSetq(L_0, clComplexImagpart(L_0__R1)); }
                  { clObject L_0__R1;
                    clSetq(L_0__R1, y);
                    clSetq(L_1, clComplexImagpart(L_0__R1)); }
                  return(clEql(L_0, L_1, clEOA)); }
              else return(clValues1(clNIL)); }
          else return(clValues1(clNIL));
        else return(clValues1(clNIL)); } } }

clObject clEqlHash clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_key473;
    { clObject L_0;
      clSetq(L_0, x);
      clSetq(L_key473, clInstanceTag(L_0)); }
    if (_clEq(L_key473, clINTEGER))
      { clObject L_test__R1;
        { clObject L_0;
          clSetq(L_0, x);
          clSetq(L_test__R1, clFixnump(L_0, clEOA)); }
        if (clTrue(L_test__R1))
          { clObject L_0;
            clSetq(L_0, x);
            return(clValues1(clEqHash(L_0))); }
        else
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, x);
              clSetq(L_0, clBignumXint(L_0__R1)); }
            return(clValues1(clDigitref(L_0, I_0))); } }
    else if (clTrue((_clEq(L_key473, clSINGLE_FLOAT) ? CONS_0 :
                     (_clEq(L_key473, clDOUBLE_FLOAT) ?
                      CONS_1 :
                      clNIL))))
      { clObject L_0;
        { clObject L_0__R1;
          { clObject L_test__R2;
            { clObject L_0__R2;
              { clObject L_0__R3;
                clSetq(L_0__R3, x);
                clSetq(L_0__R2,
                       clFuncallFunction(clSymbolFunctionValue(clABS),
                                         L_0__R3,
                                         clEOA)); }
              clSetq(L_test__R2,
                     clFuncallFunction(clSymbolFunctionValue(clLT),
                                       L_0__R2,
                                       I_1000,
                                       clEOA)); }
            if (clTrue(L_test__R2))
              { clObject L_0__R2;
                clSetq(L_0__R2, x);
                clSetq(L_0__R1,
                       clFuncallFunction(clSymbolFunctionValue(clMULT),
                                         L_0__R2,
                                         I_1000,
                                         clEOA)); }
            else clSetq(L_0__R1, x); }
          clSetq(L_0, clFloor(L_0__R1, clEOA)); }
        return(clEqlHash(L_0, clEOA)); }
    else if (_clEq(L_key473, clRATIO))
      { clObject L_1, L_0;
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, x);
            clSetq(L_0__R1, clRatioNumerator(L_0__R2)); }
          clSetq(L_0, clEqlHash(L_0__R1, clEOA)); }
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, x);
            clSetq(L_0__R1, clRatioDenominator(L_0__R2)); }
          clSetq(L_1, clEqlHash(L_0__R1, clEOA)); }
        return(clValues1(clMergeHashCodes(L_0, L_1))); }
    else if (_clEq(L_key473, clCOMPLEX))
      { clObject L_1, L_0;
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, x);
            clSetq(L_0__R1, clComplexRealpart(L_0__R2)); }
          clSetq(L_0, clEqlHash(L_0__R1, clEOA)); }
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, x);
            clSetq(L_0__R1, clComplexImagpart(L_0__R2)); }
          clSetq(L_1, clEqlHash(L_0__R1, clEOA)); }
        return(clValues1(clMergeHashCodes(L_0, L_1))); }
    else
      { clObject L_0;
        clSetq(L_0, x);
        return(clValues1(clEqHash(L_0))); } } }

clObject clListEq clVdecl(_ap)
{ clObject x, y;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(y, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject x__R1, y__R1;
    clSetq(x__R1, x);
    clSetq(y__R1, y);
    clLabel(l_ITERATE475);
    { clObject L_test;
      { clObject L_g476;
        clSetq(L_g476, clEndp(x__R1, clEOA));
        clSetq(L_test,
               (clTrue(L_g476) ? L_g476 : clEndp(y__R1, clEOA))); }
      if (clTrue(L_test))
        { clObject L_0;
          clSetq(L_0, (clTrue(x__R1) ? x__R1 : y__R1));
          return(clNot(L_0, clEOA)); } }
    { clObject x__R2, y__R2;
      clSetq(x__R2, clCar(x__R1, clEOA));
      clSetq(y__R2, clCar(y__R1, clEOA));
      { clObject L_test;
        { clObject L_0;
          { clObject L_g478;
            clSetq(L_g478, clEq(x__R2, y__R2, clEOA));
            clSetq(L_0,
                   (clTrue(L_g478) ? L_g478 :
                    (clTrue(clConsp(x__R2, clEOA)) ?
                     (clTrue(clConsp(y__R2, clEOA)) ?
                      clListEq(x__R2, y__R2, clEOA) :
                      clNIL) :
                     clNIL))); }
          clSetq(L_test, clNot(L_0, clEOA)); }
        if (clTrue(L_test)) return(clValues1(clNIL)); } }
    { clObject L_value479, L_value480;
      clSetq(L_value479, clCdr(x__R1, clEOA));
      clSetq(L_value480, clCdr(y__R1, clEOA));
      clSetq(x__R1, L_value479);
      clSetq(y__R1, L_value480); }
    goto l_ITERATE475; } }

clObject clNot clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, object);
    return(clEq(L_0, clNIL, clEOA)); } }

clObject clBoundp clVdecl(_ap)
{ clObject symbol;
  { clBeginParse(_ap);
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      clSetq(L_0, symbol);
      clSetq(L_test, clSymbolp(L_0, clEOA)); }
    if (clTrue(L_test))
      { clObject L_0;
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, symbol);
            clSetq(L_0__R1, clSymbolValueValue(L_0__R2)); }
          clSetq(L_0, clUnboundp(L_0__R1)); }
        return(clNot(L_0, clEOA)); }
    else
      { clObject L_4;
        clSetq(L_4, symbol);
        return(clError(clTYPE_ERROR,
                       keyEXPECTED_TYPE,
                       clSYMBOL,
                       keyDATUM,
                       L_4,
                       clEOA)); } } }

clObject clFdefinition1 clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject setfp, key;
    { clObject L_0;
      clSetq(L_0, name);
      clSetq(setfp, clSetfFunctionNameP(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, name);
      clSetq(key, clFunctionNameKey(L_0, setfp, clEOA)); }
    if (clTrue(setfp))
      return(clValues1(clSymbolSetfFunctionValue(key)));
    else return(clValues1(clSymbolFunctionValue(key))); } }

clObject clSetFdefinition1 clVdecl(_ap)
{ clObject name, value;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(value,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject setfp, key;
    { clObject L_0;
      clSetq(L_0, name);
      clSetq(setfp, clSetfFunctionNameP(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, name);
      clSetq(key, clFunctionNameKey(L_0, setfp, clEOA)); }
    if (clTrue(setfp))
      { clObject L_1;
        clSetq(L_1, value);
        return(clValues1(clSetSymbolSetfFunctionValue(key, L_1))); }
    else
      { clObject L_1;
        clSetq(L_1, value);
        return(clValues1(clSetSymbolFunctionValue(key, L_1))); } } }

clObject clFboundp clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, name);
        clSetq(L_0__R1, clFdefinition1(L_0__R2, clEOA)); }
      clSetq(L_0, clNull(L_0__R1, clEOA)); }
    return(clNot(L_0, clEOA)); } }

clObject clFdefinition clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g481;
    { clObject L_0;
      clSetq(L_0, name);
      clSetq(L_g481, clFdefinition1(L_0, clEOA)); }
    if (clTrue(L_g481))
      return(clValues1(L_g481));
    else
      { clObject L_2;
        clSetq(L_2, name);
        return(clError(clUNDEFINED_FUNCTION,
                       keyNAME,
                       L_2,
                       clEOA)); } } }

clObject clFmakunbound clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, name);
    clSetFdefinition1(L_0, clNIL, clEOA); }
  return(clValues1(name)); }

clObject cl_SETF_Fdefinition clVdecl(_ap)
{ clObject function, name;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, name);
    clSetq(L_1, function);
    return(clSetFdefinition1(L_0, L_1, clEOA)); } }

clObject clMap1 clVdecl(_ap)
{ clObject function, original_arglists, accumulate, take_car;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(original_arglists,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(accumulate,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(take_car,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject arglists, ret_list, temp;
    { clObject L_0;
      clSetq(L_0, original_arglists);
      clSetq(arglists, clCopyList(L_0, clEOA)); }
    clSetq(ret_list, clList(clNIL, clEOA));
    clSetq(temp, ret_list);
    { clObject res, args;
      clSetq(res, clNIL);
      clSetq(args, clNIL);
      clLabel(l_ITERATE482);
      { clObject L_test;
        { clObject L_sublist483, x;
          clSetq(L_sublist483, arglists);
          clSetq(x, clCar(L_sublist483, clEOA));
          clLabel(l_ITERATE484);
          if (clTrue(clEndp(L_sublist483, clEOA)))
            { clSetq(L_test, clNIL); clLocalReturn(NIL); }
          if (clTrue(clNull(x, clEOA)))
            { clSetq(L_test, clT); clLocalReturn(NIL); }
          { clObject L_0;
            clSetq(L_0, L_sublist483);
            clSetq(L_sublist483, clCdr(L_0, clEOA)); }
          { clObject L_0;
            clSetq(L_0, L_sublist483);
            clSetq(x, clCar(L_0, clEOA)); }
          goto l_ITERATE484; }
        clBlockEnd(NIL);
        if (clTrue(L_test))
          if (clTrue(accumulate))
            return(clCdr(ret_list, clEOA));
          else
            { clObject L_0;
              clSetq(L_0, original_arglists);
              return(clCar(L_0, clEOA)); } }
      { clObject l;
        clSetq(l, arglists);
        clLabel(l_ITERATE485);
        if (clTrue(clNull(l, clEOA))) clLocalReturn(NIL__r1);
        { clObject L_1, L_0;
          clSetq(L_0,
                 (clTrue(take_car) ? clCaar(l, clEOA) :
                  clCar(l, clEOA)));
          clSetq(L_1, args);
          clSetq(args, clCons(L_0, L_1, clEOA)); }
        { clObject L_g487;
          clSetq(L_g487, clCdar(l, clEOA));
          clRplaca(l, L_g487, clEOA);
          (void) L_g487; }
        { clObject L_value488;
          clSetq(L_value488, clCdr(l, clEOA));
          clSetq(l, L_value488); }
        goto l_ITERATE485; }
      clBlockEnd(NIL__r1);
      { clObject L_1, L_0;
        clSetq(L_0, function);
        { clObject L_0__R1;
          clSetq(L_0__R1, args);
          clSetq(L_1,
                 clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                   L_0__R1,
                                   clEOA)); }
        clSetq(res, clApply(L_0, L_1, clEOA)); }
      { clObject L_key489;
        clSetq(L_key489, accumulate);
        if (_clEq(L_key489, keyNCONC))
          { clObject L_0;
            { clObject L_1;
              clSetq(L_1, res);
              clSetq(L_0, clNconc(temp, L_1, clEOA)); }
            clSetq(temp, clLast(L_0, clEOA)); }
        else if (_clEq(L_key489, keyLIST))
          { { clObject L_1, L_0;
              clSetq(L_0, temp);
              { clObject L_0__R1;
                clSetq(L_0__R1, res);
                clSetq(L_1, clList(L_0__R1, clEOA)); }
              clRplacd(L_0, L_1, clEOA); }
            { clObject L_0;
              clSetq(L_0, temp);
              clSetq(temp, clCdr(L_0, clEOA)); } } }
      clSetq(args, clNIL);
      goto l_ITERATE482; } } }

clObject clMapcar clVdecl(_ap)
{ clObject function, lists;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(lists, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, function);
    return(clMap1(L_0, lists, keyLIST, clT, clEOA)); } }

clObject clMapcan clVdecl(_ap)
{ clObject function, lists;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(lists, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, function);
    return(clMap1(L_0, lists, keyNCONC, clT, clEOA)); } }

clObject clMapc clVdecl(_ap)
{ clObject function, lists;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(lists, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, function);
    return(clMap1(L_0, lists, clNIL, clT, clEOA)); } }

clObject clKeyItem clVdecl(_ap)
{ clObject key, item;
  { clBeginParse(_ap);
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(item,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(key))
    { clObject L_1, L_0;
      clSetq(L_0, key);
      clSetq(L_1, item);
      return(clFuncall(L_0, L_1, clEOA)); }
  else return(clValues1(item)); }

clObject clSatisfiesTheTest clVdecl(_ap)
{ clObject item, x, test, test_not, key;
  { clBeginParse(_ap);
    clSetq(item,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(test_not,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_5, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject f, item2, ok;
    { clObject L_g491;
      clSetq(L_g491, test_not);
      if (clTrue(L_g491))
        clSetq(f, L_g491);
      else
        { clObject L_g492;
          clSetq(L_g492, test);
          clSetq(f,
                 (clTrue(L_g492) ? L_g492 :
                  clSymbolFunctionValue(clEQL))); } }
    { clObject L_1, L_0;
      clSetq(L_0, key);
      clSetq(L_1, x);
      clSetq(item2, clKeyItem(L_0, L_1, clEOA)); }
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0, item);
        clSetq(L_test, clEq(L_0, clNONE, clEOA)); }
      if (clTrue(L_test))
        { clObject L_0;
          clSetq(L_0, f);
          clSetq(ok, clFuncall(L_0, item2, clEOA)); }
      else
        { clObject L_1, L_0;
          clSetq(L_0, f);
          clSetq(L_1, item);
          clSetq(ok, clFuncall(L_0, L_1, item2, clEOA)); } }
    if (clTrue(test_not))
      { clObject L_0; clSetq(L_0, ok); return(clNot(L_0, clEOA)); }
    else return(clValues1(ok)); } }

clObject clLengthList clVdecl(_ap)
{ clObject list;
  { clBeginParse(_ap);
    clSetq(list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject list__R1, n;
    clSetq(list__R1, list);
    clSetq(n, I_0);
    clLabel(l_ITERATE493);
    if (clTrue(clEndp(list__R1, clEOA))) return(clValues1(n));
    { clObject L_value494, L_value495;
      clSetq(L_value494, clCdr(list__R1, clEOA));
      clSetq(L_value495, clAddIntegerInteger(n, I_1));
      clSetq(list__R1, L_value494);
      clSetq(n, L_value495); }
    goto l_ITERATE493; } }

clObject clLength clVdecl(_ap)
{ clObject sequence;
  { clBeginParse(_ap);
    clSetq(sequence,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_key496;
    { clObject L_0;
      clSetq(L_0, sequence);
      clSetq(L_key496, clInstanceTag(L_0)); }
    if (_clEq(L_key496, clNULL))
      return(clValues1(I_0));
    else if (_clEq(L_key496, clCONS))
      { clObject L_0;
        clSetq(L_0, sequence);
        return(clLengthList(L_0, clEOA)); }
    else if (clTrue((_clEq(L_key496, clSIMPLE_BASE_STRING) ? CONS_4 :
                     (_clEq(L_key496, clSIMPLE_EXTENDED_STRING) ?
                      CONS_5 :
                      (_clEq(L_key496, clSIMPLE_BIT_VECTOR) ?
                       CONS_6 :
                       (_clEq(L_key496, clSIMPLE_VECTOR) ?
                        CONS_7 :
                        clNIL))))))
      { clObject L_0;
        clSetq(L_0, sequence);
        return(clValues1(clVectorSize(L_0))); }
    else if (clTrue((_clEq(L_key496, clCOMPLEX_BASE_STRING) ? CONS_8 :
                     (_clEq(L_key496, clCOMPLEX_EXTENDED_STRING) ?
                      CONS_9 :
                      (_clEq(L_key496, clCOMPLEX_BIT_VECTOR) ?
                       CONS_10 :
                       (_clEq(L_key496, clCOMPLEX_VECTOR) ?
                        CONS_11 :
                        (_clEq(L_key496, clBASE_STRING) ?
                         CONS_12 :
                         (_clEq(L_key496, clEXTENDED_STRING) ?
                          CONS_13 :
                          (_clEq(L_key496, clBIT_VECTOR) ?
                           CONS_14 :
                           (_clEq(L_key496, clGENERAL_VECTOR) ?
                            CONS_15 :
                            clNIL))))))))))
      { clObject L_0;
        clSetq(L_0, sequence);
        return(clValues1(clComplexArrayFillPointer(L_0))); }
    else
      { clObject L_2;
        clSetq(L_2, sequence);
        return(clError(clTYPE_ERROR,
                       keyDATUM,
                       L_2,
                       keyEXPECTED_TYPE,
                       clSEQUENCE,
                       clEOA)); } } }

clObject clEndp clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, object);
        clSetq(L_0, clConsp(L_0__R1, clEOA)); }
      clSetq(L_test, clNot(L_0, clEOA)); }
    if (clTrue(L_test))
      { clObject L_g499;
        { clObject L_0;
          clSetq(L_0, object);
          clSetq(L_g499, clNull(L_0, clEOA)); }
        if (clTrue(L_g499))
          return(clValues1(L_g499));
        else
          { clObject L_2;
            clSetq(L_2, object);
            return(clError(clTYPE_ERROR,
                           keyDATUM,
                           L_2,
                           keyEXPECTED_TYPE,
                           clLIST,
                           clEOA)); } }
    else return(clValues1(clNIL)); } }

clObject clIdentity clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(object)); }

clDeclareEnv(clComplement_Lambda);
static clObject clComplement_Lambda clVdecl(_ap)
{ clUseEnv(clComplement_Lambda);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clEnv(0, *fn));
        clSetq(L_0, clApply(L_0__R1, args, clEOA)); }
      return(clNot(L_0, clEOA)); } } }

clObject clComplement clVdecl(_ap)
{ clObject *fn = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(*fn,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(clMakeClosure(1,
                                 clComplement_Lambda,
                                 &clEnvHook(clComplement_Lambda),
                                 &*fn))); }

void clInitKernel __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(I_6, clIntFixnum(6));
  clSetq(I_0, clIntFixnum(0));
  clSetq(CONS_1, clCons(clDOUBLE_FLOAT, clNIL, clEOA));
  clSetq(CONS_0, clCons(clSINGLE_FLOAT, CONS_1, clEOA));
  clSetq(I_1000, clIntFixnum(1000));
  clSetq(STR_EXPECTED_TYPE__0,
         clCharpSimpleBaseString("EXPECTED-TYPE"));
  clSetq(keyEXPECTED_TYPE, clMakeKeyword(STR_EXPECTED_TYPE__0, clEOA));
  clSetq(STR_DATUM__1, clCharpSimpleBaseString("DATUM"));
  clSetq(keyDATUM, clMakeKeyword(STR_DATUM__1, clEOA));
  clSetq(STR_NAME__2, clCharpSimpleBaseString("NAME"));
  clSetq(keyNAME, clMakeKeyword(STR_NAME__2, clEOA));
  clSetq(CONS_3, clCons(clFDEFINITION, clNIL, clEOA));
  clSetq(CONS_2, clCons(clSETF, CONS_3, clEOA));
  clSetq(I_3, clIntFixnum(3));
  clSetq(I_4, clIntFixnum(4));
  clSetq(STR_NCONC__3, clCharpSimpleBaseString("NCONC"));
  clSetq(keyNCONC, clMakeKeyword(STR_NCONC__3, clEOA));
  clSetq(STR_LIST__4, clCharpSimpleBaseString("LIST"));
  clSetq(keyLIST, clMakeKeyword(STR_LIST__4, clEOA));
  clSetq(I_5, clIntFixnum(5));
  clSetq(CONS_7, clCons(clSIMPLE_VECTOR, clNIL, clEOA));
  clSetq(CONS_6, clCons(clSIMPLE_BIT_VECTOR, CONS_7, clEOA));
  clSetq(CONS_5, clCons(clSIMPLE_EXTENDED_STRING, CONS_6, clEOA));
  clSetq(CONS_4, clCons(clSIMPLE_BASE_STRING, CONS_5, clEOA));
  clSetq(CONS_15, clCons(clGENERAL_VECTOR, clNIL, clEOA));
  clSetq(CONS_14, clCons(clBIT_VECTOR, CONS_15, clEOA));
  clSetq(CONS_13, clCons(clEXTENDED_STRING, CONS_14, clEOA));
  clSetq(CONS_12, clCons(clBASE_STRING, CONS_13, clEOA));
  clSetq(CONS_11, clCons(clCOMPLEX_VECTOR, CONS_12, clEOA));
  clSetq(CONS_10, clCons(clCOMPLEX_BIT_VECTOR, CONS_11, clEOA));
  clSetq(CONS_9, clCons(clCOMPLEX_EXTENDED_STRING, CONS_10, clEOA));
  clSetq(CONS_8, clCons(clCOMPLEX_BASE_STRING, CONS_9, clEOA));
  clSetq(I_10, clIntFixnum(10));
  clSetq(STR_UPCASE__5, clCharpSimpleBaseString("UPCASE"));
  clSetq(keyUPCASE, clMakeKeyword(STR_UPCASE__5, clEOA));
  clSetq(I_40, clIntFixnum(40));
  clSetq(I_72, clIntFixnum(72));

  cl_SETF_GlobalDeclaration(clT,
                            clstarSTANDARD_INPUTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarSTANDARD_INPUTstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarSTANDARD_OUTPUTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarSTANDARD_OUTPUTstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarERROR_OUTPUTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarERROR_OUTPUTstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarTERMINAL_IOstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarTERMINAL_IOstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarDEBUG_IOstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarDEBUG_IOstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarQUERY_IOstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarQUERY_IOstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarTRACE_OUTPUTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarTRACE_OUTPUTstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarNULL_OUTPUTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarNULL_OUTPUTstar;
  clSetSymbolFunctionValue(clCLASS_NAME_OF,
                           clMakeClosure(0,
                                         clClassNameOf,
                                         clNULL_HOOK));
  (void) clCLASS_NAME_OF;
  clSetSymbolFunctionValue(clCLASS_PRECEDENCE_LIST_OF,
                           clMakeClosure(0,
                                         clClassPrecedenceListOf,
                                         clNULL_HOOK));
  (void) clCLASS_PRECEDENCE_LIST_OF;
  clSetSymbolFunctionValue(clFIND_LIST_EQ,
                           clMakeClosure(0,
                                         clFindListEq,
                                         clNULL_HOOK));
  (void) clFIND_LIST_EQ;
  clSetSymbolFunctionValue(clNULL,
                           clMakeClosure(0, clNull, clNULL_HOOK));
  (void) clNULL;
  clSetSymbolFunctionValue(clATOM,
                           clMakeClosure(0, clAtom, clNULL_HOOK));
  (void) clATOM;
  clSetSymbolFunctionValue(clCONSP,
                           clMakeClosure(0, clConsp, clNULL_HOOK));
  (void) clCONSP;
  clSetSymbolFunctionValue(clCHARACTERP,
                           clMakeClosure(0,
                                         clCharacterp,
                                         clNULL_HOOK));
  (void) clCHARACTERP;
  clSetSymbolFunctionValue(clINTEGERP,
                           clMakeClosure(0, clIntegerp, clNULL_HOOK));
  (void) clINTEGERP;
  clSetSymbolFunctionValue(clCOMPLEXP,
                           clMakeClosure(0, clComplexp, clNULL_HOOK));
  (void) clCOMPLEXP;
  clSetSymbolFunctionValue(clSIMPLE_VECTOR_P,
                           clMakeClosure(0,
                                         clSimpleVectorP,
                                         clNULL_HOOK));
  (void) clSIMPLE_VECTOR_P;
  clSetSymbolFunctionValue(clSIMPLE_BIT_VECTOR_P,
                           clMakeClosure(0,
                                         clSimpleBitVectorP,
                                         clNULL_HOOK));
  (void) clSIMPLE_BIT_VECTOR_P;
  clSetSymbolFunctionValue(clRATIOP,
                           clMakeClosure(0, clRatiop, clNULL_HOOK));
  (void) clRATIOP;
  clSetSymbolFunctionValue(clSINGLE_FLOAT_P,
                           clMakeClosure(0,
                                         clSingleFloatP,
                                         clNULL_HOOK));
  (void) clSINGLE_FLOAT_P;
  clSetSymbolFunctionValue(clDOUBLE_FLOAT_P,
                           clMakeClosure(0,
                                         clDoubleFloatP,
                                         clNULL_HOOK));
  (void) clDOUBLE_FLOAT_P;
  clSetSymbolFunctionValue(clSYMBOLP,
                           clMakeClosure(0, clSymbolp, clNULL_HOOK));
  (void) clSYMBOLP;
  clSetSymbolFunctionValue(clLISTP,
                           clMakeClosure(0, clListp, clNULL_HOOK));
  (void) clLISTP;
  clSetSymbolFunctionValue(clEQL,
                           clMakeClosure(0, clEql, clNULL_HOOK));
  (void) clEQL;
  clSetSymbolFunctionValue(clEQL_HASH,
                           clMakeClosure(0, clEqlHash, clNULL_HOOK));
  (void) clEQL_HASH;
  clSetSymbolFunctionValue(clLIST_EQ,
                           clMakeClosure(0, clListEq, clNULL_HOOK));
  (void) clLIST_EQ;
  clSetSymbolFunctionValue(clNOT,
                           clMakeClosure(0, clNot, clNULL_HOOK));
  (void) clNOT;
  clSetSymbolFunctionValue(clBOUNDP,
                           clMakeClosure(0, clBoundp, clNULL_HOOK));
  (void) clBOUNDP;
  clSetSymbolFunctionValue(clFDEFINITION1,
                           clMakeClosure(0,
                                         clFdefinition1,
                                         clNULL_HOOK));
  (void) clFDEFINITION1;
  clSetSymbolFunctionValue(clSET_FDEFINITION1,
                           clMakeClosure(0,
                                         clSetFdefinition1,
                                         clNULL_HOOK));
  (void) clSET_FDEFINITION1;
  clSetSymbolFunctionValue(clFBOUNDP,
                           clMakeClosure(0, clFboundp, clNULL_HOOK));
  (void) clFBOUNDP;
  clSetSymbolFunctionValue(clFDEFINITION,
                           clMakeClosure(0,
                                         clFdefinition,
                                         clNULL_HOOK));
  (void) clFDEFINITION;
  clSetSymbolFunctionValue(clFMAKUNBOUND,
                           clMakeClosure(0,
                                         clFmakunbound,
                                         clNULL_HOOK));
  (void) clFMAKUNBOUND;
  clSetSymbolSetfFunctionValue(clFDEFINITION,
                               clMakeClosure(0,
                                             cl_SETF_Fdefinition,
                                             clNULL_HOOK));
  (void) CONS_2;
  clSetSymbolFunctionValue(clMAP1,
                           clMakeClosure(0, clMap1, clNULL_HOOK));
  (void) clMAP1;
  clSetSymbolFunctionValue(clMAPCAR,
                           clMakeClosure(0, clMapcar, clNULL_HOOK));
  (void) clMAPCAR;
  clSetSymbolFunctionValue(clMAPCAN,
                           clMakeClosure(0, clMapcan, clNULL_HOOK));
  (void) clMAPCAN;
  clSetSymbolFunctionValue(clMAPC,
                           clMakeClosure(0, clMapc, clNULL_HOOK));
  (void) clMAPC;
  clSetSymbolFunctionValue(clKEY_ITEM,
                           clMakeClosure(0, clKeyItem, clNULL_HOOK));
  (void) clKEY_ITEM;
  clSetSymbolFunctionValue(clSATISFIES_THE_TEST,
                           clMakeClosure(0,
                                         clSatisfiesTheTest,
                                         clNULL_HOOK));
  (void) clSATISFIES_THE_TEST;
  clSetSymbolFunctionValue(clLENGTH_LIST,
                           clMakeClosure(0,
                                         clLengthList,
                                         clNULL_HOOK));
  (void) clLENGTH_LIST;
  clSetSymbolFunctionValue(clLENGTH,
                           clMakeClosure(0, clLength, clNULL_HOOK));
  (void) clLENGTH;
  clSetSymbolFunctionValue(clENDP,
                           clMakeClosure(0, clEndp, clNULL_HOOK));
  (void) clENDP;
  cl_SETF_GlobalDeclaration(clT,
                            clstarFEATURESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarFEATURESstar;
  clSetSymbolFunctionValue(clIDENTITY,
                           clMakeClosure(0, clIdentity, clNULL_HOOK));
  (void) clIDENTITY;
  clSetSymbolFunctionValue(clCOMPLEMENT,
                           clMakeClosure(0,
                                         clComplement,
                                         clNULL_HOOK));
  (void) clCOMPLEMENT;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_BASEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_BASEstar, I_10);
  (void) clstarPRINT_BASEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_CASEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_CASEstar, keyUPCASE);
  (void) clstarPRINT_CASEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_CIRCLEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_CIRCLEstar, clNIL);
  (void) clstarPRINT_CIRCLEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_ESCAPEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_ESCAPEstar, clT);
  (void) clstarPRINT_ESCAPEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_GENSYMstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_GENSYMstar, clT);
  (void) clstarPRINT_GENSYMstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_LENGTHstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_LENGTHstar, clNIL);
  (void) clstarPRINT_LENGTHstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_LEVELstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_LEVELstar, clNIL);
  (void) clstarPRINT_LEVELstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_LINESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_LINESstar, clNIL);
  (void) clstarPRINT_LINESstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_RADIXstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_RADIXstar, clNIL);
  (void) clstarPRINT_RADIXstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_READABLYstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_READABLYstar, clNIL);
  (void) clstarPRINT_READABLYstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_RIGHT_MARGINstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_RIGHT_MARGINstar, clNIL);
  (void) clstarPRINT_RIGHT_MARGINstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_ARRAYstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_ARRAYstar, clT);
  (void) clstarPRINT_ARRAYstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_PRETTYstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_PRETTYstar, clNIL);
  (void) clstarPRINT_PRETTYstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPRINT_MISER_WIDTHstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPRINT_MISER_WIDTHstar, I_40);
  (void) clstarPRINT_MISER_WIDTHstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarDEFAULT_RIGHT_MARGINstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarDEFAULT_RIGHT_MARGINstar, I_72);
  (void) clstarDEFAULT_RIGHT_MARGINstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarCURRENT_LEVELstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarCURRENT_LEVELstar, I_0);
  (void) clstarCURRENT_LEVELstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarCURRENT_LENGTHstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarCURRENT_LENGTHstar, I_0);
  (void) clstarCURRENT_LENGTHstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarCIRCULARITY_HASH_TABLEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarCIRCULARITY_HASH_TABLEstar, clNIL);
  (void) clstarCIRCULARITY_HASH_TABLEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarPARENTSstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarPARENTSstar, clNIL);
  (void) clstarPARENTSstar;
  clUnwind(4); }
